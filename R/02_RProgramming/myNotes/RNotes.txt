R is a dialect of S
S is a language developed by Bell Labs (1976) internal statistical analysis as Fortran libraries
Early versions did not contain function
1988, re-written in C
"Statistical Models in S" 
1998 V.4
"Programming with Data" John Chambers (The Green Book)
1993, Bell Labs gave it to StatSci

1991 - R
Paper in 1996
Ross and Robert, made R free software
Two main mailing lists, RHelp and RDevelop
R even runs on PlayStation 3
Useful for interactive work
Very active user community
Free:
	Doesn't cost anything
	Free Software: 
	Free Software Foundation
	0: To run for any purpose
	1: Freedom to study how the program works, make changes to it yourself, sell changes etc.
	2: Freedom to redistribute, can sell copies
	3: Can improve the program to benefit the entire community
	 
Drawbacks: 
	Based on 4-year-old technology. Little built-in support for dynamic or 3d Graphics
	Functionality is based on community demand. If nobody has seen fit to implement the
	feature that you would like, you have to do it yourself
	Objects you create have to be stored in the physical memory of your computer
	If the objects you create are larger, then you have to deal with that yourself
	Not ideal for all possible situations
	Larger and larger datasets makes a limitation of the fact that the objects must be loaded
	into physical memory.
	
Two Conceptual Parts
1: Base R System
	Base package, all the low-level functionality you need to run the R system.
	From CRAN
	Other packages, utils stats, data sets graphics, fundamental packages
	Other recommended packages, boot, class, cluster, codetools, etc..
	Commonly-used packages
	 
2: Everything Else
	There are alo about 4,000 other packages on CRAN which are user-contributed.
	CRAN has a number of restrictions in order to get a package onto CRAN
	Documentation for all functions, pass tests etc.
	Also packages associated with the bio-conductor project, genomic and biological data analysis.
	
Some R resources
	1: An introduction to R, a long PDF document.
	2: Writing R extensions manual, for developers of packages
	3: RData Import and Export manual
	4: R installation and Administration manual
	5: RInternals manual, a really technical document about the internals of R
	
Standard Texts
	John Chambers
	Venables and Ripley
	Pinheiro and Bates
	Murrell - RGraphics
	
	Springer: Use R!
	A longer list of books also at R web site
	
Getting Help
	Asking Questions
		Steps to reproduce the problem
		Expected output
		What you see instead
		What version of the product and Libraries are you using
		What OS
		Additional Information
	Subject Heading in Emails, make it very clear
	
	Describe the goal, not the step
	Be explicit about your question
	Provide the minimum amount of information necessary
	Be courteous
	Follow up with the solution if and when you get it resolved
	
	DO NOT claim you found a bug because you can't get it to work
	Don't email multiple mailing lists at once
	Specify where you think the problem is
	
	Example of wasting a cycle of emails and responses by asking such a vague and high-level
	issue, with no evidence that the writer ever made any effort to resolve it themselves
	
	Class discussion board
	R-Help mailing list
	Other project-specific emailing lists	
	
	
Evaluation
	Evaluated and printed
	If the expression evaluates to nothing, then there is nothing to show;
	[1] indicates the first element of the vector.
	If we store a single element object it is still stored as a vector
	
R Data Types - Objects and Attributes
	Basic, atomic classes.
	character, numeric, integer, complex and logical
	The most basic object in R is a  x <- 1:4 , which can be a vetor of consistent object types
	Everything in a vector has to be of the same class.
	The list, is a type of vector that can have objects of different classes
	vector function, class and length
	R treats numbers as double precision types, but you can force it to use integer by using captal L
	1L is an integer, 1 is 1.00f
	Inf is infinity
	NaN is also included
	R objects can have attributes;
		names, dimnames, dimensions, class, length,  other user-defined attributes and meta-data
		Attributes of an object can be accessed using the attributes() function
		
	
Creating Vectors
	C function to create vectors
	c == Concatenate things
	including complex numbers
	vector function can create a vector of a type and length, buy default initialised to 0
	
Vector of mixed objects, coerce the vector to be the class of the least common denominator class
	number and string gives a vector of strings
	numeric and boolean converted to vector of numbers
	letter and boolean is converted to a character vector
	be aware of the coercion that occurs in R
	
	You can explicitly coerce using the as.* functions
	This represents the data as the specified type, but does not alter the state of the operated object
	it simply presents it as a different class
	x <- 0:6
	as.numeric(x);
	as.logical(x);
	as.character(x);
	Coercion does not always work and NaN will be returned when it does not make sense
	
	list function()
	Different from vectors in that every element of a list could be an object of a different class
	elements of lists are indexed using the double brackets
	elements of other types of vector are indexed with only single brackets around them

Data Types : Matrices
	Special type of vector
	vectors that have a dimension attribute, vector of dimension 2, rows and columns
	m <- matrix(nrow=5, ncol=6);
	attributes(m)
	matrix are constructed column-wise, first column gets filled before second column is started
	m <- matrix(1:6, nrow=5, ncol=6);
	can also convert a vector to a matrix by assigning the dim attribute to the number of 
	rows and columns in the vector data
	m <- 1:10
	dim(n) <- c(2,5)
	matrices can be created by binding columns or by binding rows
	x <- 1:3
	y <- 10:12
	cbind(x,y)
	rbind(x,y)
	Creates a matrix either with 3,2 rows and columns or 2,3 rows and columns
	
Factor
	Factor is a special type of vector for storing data that are either unordered, Male/Female
	or categorical and ordered, L, SL1, SL2, SL3
	Can deine High, Medium, Low, for example in an ordered Factor
	Factors are treated specially by modelling functions such as lm() and glm()
	Factors with labels better than integer variables.
	variable Male/Female better than just 1/2.
	
	x <-factor(c("yes","yes","no","no","no"))
	> x
		[1] yes yes no  no  no 
		Levels: no yes
	> table(x)
		x
		 no yes 
		  3   2 
	> unclass(x)
		[1] 2 2 1 1 1
		attr(,"levels")
		[1] "no"  "yes"


	Ordinarily "no" is baseline level, because "no" comes before "yes" in the alphabet
	We can set the order of the levels in the factor vector by specifying it upon creation
	f <- factor(c("yes","yes","no","no","yes"), levels = c("yes","no"))
	Useful if the factor variables are based on some sort of baseline level
	single:1 double:1
	
Missing Values 
	denoted by either NA or NaN
	is.na() tests objects to see if they are missing values
	is.nan() tests for NaNs
	NA values can also have a class, the missing object can also have a class
	a NaN is also a missing NA, but not vice versa
	
	> g <- c(1, 2, NA, 4, 5)
	> g
		[1]  1  2 NA  4  5
	> is.na(g)
		[1] FALSE FALSE  TRUE FALSE FALSE
		
	> g <- c(1, 2, NA, NaN, 5)
	> g
		[1]   1   2  NA NaN   5
	> is.na(g)
		[1] FALSE FALSE  TRUE  TRUE FALSE
	> is.nan(g)
		[1] FALSE FALSE FALSE  TRUE FALSE
	
Data Frames
	Used to store Tabular Data
	Represented as a special type of list where every element has the same length
	Each column does not have to be same type
	Unlike Matrices which have to store the same types in each cel
	Every row can have a name rowname, but often we use 1,2,3
	read.table read.csv
	can also create a matrix from a  table by calling the matrix.table function
	forces coercion
	Dataframes can be created using the data.frame function
	specifying the column names
	> x <- data.frame(foo=1:4, bar=c(T,T,F,F));
	> x
		foo   bar
	1   1  TRUE
	2   2  TRUE
	3   3 FALSE
	4   4 FALSE
	> nrow(x)
		[1] 4
	> ncol(x)
		[1] 2

Names
	All R objects can also have names
	Very useful for writing readable code and self-derscribing objects
	> w <- 1:3
	> w
		[1] 1 2 3
	> names(w) <- c("foo","bar","norf");
	> w
		foo  bar norf 
		1    2    3 
	> names(w);
		[1] "foo"  "bar"  "norf"
	
	Lists can also have names
	
	> v <- list(a=1, b=2, c=4);
	> v
	$a
	[1] 1

	$b
	[1] 2

	$c
	[1] 4
	
	Matrices can have names
	> m <- matrix(1:4, nrow=2, ncol=2);
	> dimnames(m) <- list(c("r1", "row2"),c("col1","c2")); 
	> m
		 col1 c2
	r1      1  3
	row2    2  4

Data Types Summary
	atomic classes, numeric logical, character, integer and complex
	vectors, lists
	factors (ordered and unordered)
	missing values (NA and NaN)
	data frames
	names
	
Reading (and Writing) Tabular Data in R
		read.table
		read.csv
	read tabular data from text files and return a data frame in R

		readLines
	gives you text as a character vector in R
	can read any type of file
	
		source
	important for reading R code
		dget
	also reads R code files, for reading R objects that have been de=parsed into text files
	(does this mean serialized?)

		load and unserialize
	are for reading binary objects into R
	
	Analogous functions for writing are
		write.table
		writeLines
		dump
		dput
		save
		serialize
		
	read.table is the most commonly used function for reading data into R
	it takes some arguments
	file or connection
	header, indicating if first line is a header line
	sep is the separator string
	colClasses is a character vector indicating the class of each column in the dataset
		length the same as the number of columns in the data
	nrows
	comment.char character string indicating the comment character, default is #
	skip the number of lines at the start to skip
		useful for ignoring start data etc.
	stringsAsFactors defaults to true, do you want to encode character variables as factors
		R assumes you want to factorize this data.
		
	read.table
		data <- read.table("foo.txt");
	will automatically try to figure things out itself
	skip lines beginning with #
	figure out how many lines etc.
	Usually not much advantage to providing specific arguments in any case, as R will do
	pretty well in figuring this out itself
	read.csv is identical to read.table except that it uses the comma, by default as the separator.
	for read.table, the default separator is the space
	read.csv always specifies header=true by default

	
Reading Large Tables
	making your life a lot easier and prevent R from choking read the help page for read.Table
	memorize it even.
	A lot of important information there on how to optimize read.data particularly for large data sets
	In particular you will want to know how much memory you need to store the dataset you are about to read.
	R will try to store the entire dataset in physical memory
	If there are no comment lines in your file, just set the comment char to be an empty string
	Using the colClasses argument correctly will also help a lot.
	If you don't, then R will go through every column and try to figure out what kind of data it is.
	That's fine for small to moderate data sets and generally slows things down.
	Will make read.table run a lot faster if used correctly.
	Even if you give only a single value here, it will assume that every column has that same value
	Otherwise, you can read in the first 100 or 100 rows by specifying the nrows argument and 
	going through each of the columns using sapply to identify the derived classes for each column
	then save this and use it as the colClasses argument for read.table to save R from having to do
	so on the larger data sets.
		initial <- read.table("datatable.txt", nrows=100);
		classes <- sapply(initial, class);
		tabAll <- read.table("rataset.txt", colClasses=classes);
		
	you should also consider setting nrows. It does not help Ro to run any faster.
	A slight overestimate is ok, but it helps r to  decide how much memory to reserve for 
	the dataset. Using the unix tool we to count the lines in the file will help here.
	
	Knowing your own system, memory available, other applications in use
	etc...
	
	Calculating memory requirements

	1,500,000 rows and 120 columns, all columns are numeric
	1,500,000 x 120 x 8bytes (8 bytes for each numeric)
	1,373.20 MB
	1.34 GB
	
Textual data formats dput() and dump()
	produce text format versions of objects
	dump or dput will include in the output the class of the data in each column of the 
	data frame. Still a textual format, but also contains meta data.
	Produces somewhat less readable output, but saves the down-stream user from having 
	to re-engineer the data classes etc.
	Textual formats can be a lot more useful than binary formats as tools like git, etc
	can more readily track meaningful changes which can be done in text formats rather than
	binary data.
	Textual data also adheres to the UNIX philosophy of storing things by text by default 
	and whenever possible. The can be rather inefficient in terms of space usage.
	
	dput
	
	> y <- data.frame(a=1, b="a")
	> dput(y);
		structure(list(a = 1, 
						b = structure(1L, .Label = "a", class = "factor")),
						.Names = c("a", "b"), 
						row.names = c(NA, -1L), 
						class = "data.frame")
	> dput(y, file="y.R");
	> new.y <-dget("y.R");
	> new.y
		  a b
		1 1 a
	> y
		  a b
		1 1 a
		
	So, we can serialize the object y, using dput and then use dget to read it back in
	
	dump is a lot like dge
	dget can only be used on a single r obhect
	dump can be used on multiple r objects
	you can pass a character vector of the names of the objects if interest.
	
	> d <- "foo";
	> e <- data.frame(a=1, b="a");
	> dump(c("d", "e"), file="deData.R");
	> rm(d,e);
	> d
		Error: object 'd' not found
	> e
		Error: object 'e' not found
	> source("deData.R");
	> d
		[1] "foo"
	> e
 		  a b
		1 1 a
		
Connections: Interfaces to the Outside World
	We can interface between R and the outside world
	functions that are used to open up 'connections' to the outside world
	most commonly to a file, or a compressed file etc.
	when we do read.tabe from a file, the connection is done in the background
	you can also open up a connection to a web page using the url function
		file
		gzfile - compressed using gzip
	 	bzfile - compressed using bzip2
		url
	file arguments
		description  
		r, w, a, rb, wb, ab
	
	con <- file("foo.txt", "r");
	data <- read.csv(con);
	close(con);
		
	above is the same as doing read.csv on the file
	useful, though, of you only want to read parts from the file
	
	con <- gzfile("words.gz");
	x <- readLines(con, 10)
	reads 10 lines from the file words.gz
	
	writeLines takes a character vector argument which writes each element one line at a 
	time to a text file
	
	readLines can also be used to read lines from a web page
	> con <- url("http://www.jhsph.edu","r");
	> x <- readLines(con)
	> head(x);
		[1] "<!DOCTYPE html>"                                               
		[2] "<html lang=\"en\">"                                            
		[3] ""                                                              
		[4] "<head>"                                                        
		[5] "<meta charset=\"utf-8\" />"                                    
		[6] "<title>Johns Hopkins Bloomberg School of Public Health</title>"
		
	
Subsetting R Objects - Basics
				
	
Quiz 1
	>  x <- 1:4 
	> y <- 2
	> x+y
		[1] 3 4 5 6
	>  x <- c(3, 5, 1, 10, 12, 6) 
	> x[x %in% 1:5] <- 0
	> x
		[1]  0  0  0 10 12  6

Subsetting R Objects - Basics
	[
	[[
	$
	can all be used for subsetting
	[ - returns an object of the same class as the original, vector/vector list/list 
		can be used to select more than one elemenbt of an object (usually)
	[[ used to extract a single element of a list or a dataframe
		the returned object will not necessarily be an instance of list or dataframe
		lists can hold things of different classes, so [[ can return different class objects
	$ used to extract elements of a list or dataframe that has a name
		otherwise semantics are the same as [[
	
	example:
		> x <- c("a", "b", "c", "c", "d", "a");
		> x[1]
		[1] "a"
		> x[2]
		[1] "b"
		> x[1:4]
		[1] "a" "b" "c" "c"
		
	these are examples of using numeric index
	but we can also subset using a logical index
	
	so we can return a character vector that returns only those letters > a, for example
	> x[x>"a"]
		[1] "b" "c" "c" "d"
	
	we can create a logical vector, u, so that it is a true or false vector meeting the condition
	of being greater than a, for example. A bit like a select statement, where the SQL
	statement is the content of the logical vector
	
	> u<- x > "a"
	> u
		[1] FALSE  TRUE  TRUE  TRUE  TRUE FALSE
	each of which match the statement x > "a", for the elements in the original vector x
	> x[u]
		[1] "b" "c" "c" "d"
	
	So we have used both a numeric index and a logical index
	
Subsetting R objects: lists
	a bit different from subsetting a vector
	> x <- list(foo=1:4, bar = 0.6);
	> x[1]
		$foo
		[1] 1 2 3 4
	> x$bar
		[1] 0.6
	> x[["bar"]]
		[1] 0.6
	> x["bar"]
	$bar
		[1] 0.6
		
	a list with two elements in it.
	[a] always returns an element with the same class as the original element
	so x[1] returns a list containing the sequence 1:4
	x[[1]] returns just the sequence 1:4
	
	subsetting an element using its name means we don't have to remember its numeric position
	
	To extract multiple elements of a list, we need to use the [ operator
	So, give me elements 1 and 3 of the original list
	> x <- list(foo=1:4, bar = 0.6, baz="hello");
	so, pass the numeric vector 1,3 to x using the single bracket operator
	which returns to me a list with elements foo and baz
	
	> x[c(1, 3)]
		$foo
		[1] 1 2 3 4

		$baz
		[1] "hello"
		
	[[ can be used to index a list where the index itself was computed
	sometimes the name of the element is the result of some computation
	so we can create a variable called name, and use that as the operator to
	the [[ operator
	
	> name <- "foo";
	> x[name]
		$foo
		[1] 1 2 3 4

	> x$name # name does not exist as a name, but only as a variable
		NULL
	> x$foo
		[1] 1 2 3 4

	[[ operator can take an integer sequence rather than just a single number.
	it recurses into the list, effectively 2-D indexing (double subsetting)
	
	> x <- list(a = list(10,12,14), b=c(3.14, 2.81))
	> x[[c(1,3)]] # element 3 of element 1
		[1] 14
	> x[[c(2,1)]] # element 1 of element 2
		[1] 3.14

Subsetting R objects: Matrices
	matrices can be subsetted in the usual way using the i,j notation
	> x <- matrix(1:6, 2, 3)
	> x[1,2]
		[1] 3
	> x[2,1]
		[1] 2
	> x[1, ] # indices can also be missing, giving row 1
		[1] 1 3 5
	> x[ ,2] # or giving column 2
		[1] 3 4

	by default when a single element of a matrix is retrieved, is returned a vector of length 1
	rather than a 1x1 matrix.
	I don't get back a matrix, but an vector with just that element in it
	so x[1,2] returns a vector with element 1,2 in it, not a matrix 1x1 containing that element
	we can override this behaviouR with the drop=FALSE argument to the subsetting operation
	by default the subsetting drops the dimension, with drop=FALSE this is not done
	so we get a 2 dimensional object back, rather than the 1 dimensional object that
	would be returned by the drop=TRUE default behaviour
	> x[1,2]
		[1] 3
	> x[1,2, drop=FALSE];
		 [,1]
	[1,]    3
	
	when you subset a single column or a single row, you don't get back a matrix
	when you subset out the first row, you might expect a matrix 1x3 containing the 
	elements of the first row. That's not what you get
	you get back a vector containing the elements of the first row
	> x <- matrix(1:6, 2, 3)
	> x[1, ]
		[1] 1 3 5
	> x[1, , drop=FALSE]
		 [,1] [,2] [,3]
	[1,]    1    3    5

Subsetting R objects: Subsetting with names
	Partial Matching - can save a lot of time at the command-line
	works with [[ and $ operators
	lets's just alias a to aardvark
	
	> x <- list(aardvark=1:5)
	> x$a
		[1] 1 2 3 4 5
	> x[["a"]]
		NULL
	> x[["a", exact = FALSE]]
		[1] 1 2 3 4 5
	
	[[ expects that the name will be an exact match, but we can suppress this by 
	specifying the exact=FALSE argument
	
Subsetting R objects, removing NA objects
	> x <- c(1, 2, NA, 4, NA, 5)
	> bad <- is.na(x)
	> bad
		[1] FALSE FALSE  TRUE FALSE  TRUE FALSE
	> x[bad]
		[1] NA NA
	> x[!bad]
		[1] 1 2 4 5

	Now, consider multiple objects, x and y, each of which have some missing values
	we can use complete.cases to create a vector containing logical values
	for complete cases, 
	TRUE if both are present, FALSE otherwise
	
	> x <- c(1, 2, NA, 4, NA, 5)
	> y <- c("a", "b", NA, "d", NA, "f")
	> good <- complete.cases(x,y);
	> good
		[1]  TRUE  TRUE FALSE  TRUE FALSE  TRUE
	> x[good]
		[1] 1 2 4 5
	> y[good]
		[1] "a" "b" "d" "f"

	you can also use complete cases to remove missing values from data frames
	in the following example, all we want are the rows where all values are non missing
	so, load the airquality data
	
	> airquality <- read.csv("hw1_data.csv");
	> airquality[1:6, ]
	  Ozone Solar.R Wind Temp Month Day
	1    41     190  7.4   67     5   1
	2    36     118  8.0   72     5   2
	3    12     149 12.6   74     5   3
	4    18     313 11.5   62     5   4
	5    NA      NA 14.3   56     5   5
	6    28      NA 14.9   66     5   6

	# build the good matrix using complete.cases
	> good <- complete.cases(airquality);
	# use the good matrix to subset airquality
	# and then take the first 6 good rows
	> airquality[good, ][1:6, ]
	  Ozone Solar.R Wind Temp Month Day
	1    41     190  7.4   67     5   1
	2    36     118  8.0   72     5   2
	3    12     149 12.6   74     5   3
	4    18     313 11.5   62     5   4
	7    23     299  8.6   65     5   7
	8    19      99 13.8   59     5   8
	
	complete.cases very useful function
	
Vectorized operations
	Makes it easy to use on the command-line and write code without having to do 
	lots of looping
	things can happen in parallel over two vectors
	> x <- 1:4; y <-6:9
	> x+y
		[1]  7  9 11 13

	we can also do vectorized operations on boolean expressions and other arithmetic 
	expressions 
	> x >2
		[1] FALSE FALSE  TRUE  TRUE
	> x >= 2
		[1] FALSE  TRUE  TRUE  TRUE
	> y ==8
		[1] FALSE FALSE  TRUE FALSE
	> x * y
		[1]  6 14 24 36
	> x / y
		[1] 0.1666667 0.2857143 0.3750000 0.4444444

	We can also apply vectorized operations to matrices
	> x <- matrix(1:4, 2, 2); y <- matrix(rep(10,4), 2, 2)
	> x * y
 	    [,1] [,2]
	[1,]   10   30
	[2,]   20   40
	
	This is not MATRIX multiplication, simply element by element multiplication
	
	> x/y
	     [,1] [,2]
	[1,]  0.1  0.3
	[2,]  0.2  0.4

	This IS matrix multiplication
	> x %*% y
     [,1] [,2]
	[1,]   40   40
	[2,]   60   60

Introduction to swirl
	Experimental feature, statistics with interactive r learning
	SWIRL
	
	
Week 2
-----
Control Structures in R
	Allow you to control the flow of an R programme
	Very similar to other languages
	if:else
	for:
	while:
	repeat:
	break:
	next: skip an iteration
	return: exit a function
	
	
if:else
	if(<condition>) 
	{
		# do something
	}
	else if(<other condition>)
	{
		# do something else
	{
	else
	{
	# do something else by default
	}
	
if(x>3) {
	y <- 10
	}else{
	y<-0
	}
	
	==or==
	
	y <- if (x>3) {
	10
	}else{
	0
	}
	
for
	for(i in 1:10) {
		print(i)
	}

	# all of these will produce the same output
	> for (i in 1:4){print(x[i])}
	# seq_along creates an integer vector based on the length of its argument
	
	> for(i in seq_along(x)) { print(x[i])}
	> for(letter in x){print(letter)}
	> for(i in 1:4) print(x[i])
		[1] "a"
		[1] "b"
		[1] "c"
		[1] "d"
		
	Nested For Looops
	> x<- matrix(1:6, 2, 3)
	> for(i in seq_len(nrow(x))){
	+ for(j in seq_len(ncol(x))){
	+ print(x[i,j])
	+ }
	+ }
		[1] 1
		[1] 3
		[1] 5
		[1] 2
		[1] 4
		[1] 6

While Loops
	> count <- 0
	> while(count < 10){
	+ print(count)
	+ count <- count+1
	+ }
		[1] 0
		[1] 1
		[1] 2
		[1] 3
		[1] 4
		[1] 5
		[1] 6
		[1] 7
		[1] 8
		[1] 9
		

Repeat, Next, Break
	repeat requires a break that is guaranteed to occur at some time
	
Next, Return
	Next, to skip an iteration of a loop
	Return as in other languages, exit andreturn values
	

Writing Functions
	
	